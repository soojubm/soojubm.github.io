<main class="component">
  <nav class="component-navigation stack" role="group" data-scroll="vertical" role="menubar">
    <div class="component-navigation-background"></div>
    <a class="chip is-active js-scrollspy-trigger" href="#"><span class="chip-label">Page</span></a>
    <a class="chip js-scrollspy-trigger" href="#"><span class="chip-label">Modal</span></a>
    <a class="chip js-scrollspy-trigger" href="#"><span class="chip-label">Post</span></a>
    <a class="chip js-scrollspy-trigger" href="#"><span class="chip-label">Sheet</span></a>
    <a class="chip js-scrollspy-trigger" href="#"><span class="chip-label">Popover</span></a>
    <a class="chip js-scrollspy-trigger" href="#"><span class="chip-label">Drawer(todo)</span></a>
  </nav>

  <section class="hero" role="banner">
    <h1 class="hero-title">Presentations</h1>
    <h1 class="hero-title">사용자가 콘텐츠를 소비하는 환경에 적합한 그릇(?)을 제공합니다. 1. 그릇은 유연하고 2. 콘텐는 독립적으로.</h1>

    <!-- const hide = () => drawer.remove()
    const show = () => layout.appendChild(drawer) -->

    <!-- <ul>
      <li>독립적인 컨테이너로서 동작해야 한다.</li>
      <li>큰 맥락에서 presentation 컴포넌트는 레이아웃(또는 컨테이너)의 역할.</li>
      <li>루트 엘리먼트가 상태 클래스를 가져야 한다. = 글로벌 상태. (특히 토스트)</li>
      <li>@mixin modal / sheet / toast / drawer</li>
      <li>컨테이너가 fixed 되어야 현재 뷰포트에서 노출할 수 있다.</li>
      <li>overay을 별도의 엘리먼트로 만들면 리액트에서 콘텐츠 외부를 클릭해서 닫는 기능 구현이 쉬움.</li>
    </ul> -->
    <!-- <p>layout :: fixed layout / fluid layout</p> -->

    <!-- <p class="hero-description">
      정리. 크로스 플랫폼을 위한 디자인에서 iOS에만 있거나 android에만 있는 요소를 혼합해서 사용하게 되면 작은 화면에서 sheet가 toast나 floating
      action button 등과 위치나 용법이 중복되기 때문에 생각할 지점이 많아진다. 사용자들에게 눈에 띄게 큰 효용을 주는 것이 아니라면, 대체 가능한 패턴을
      활용하면 관리 비용을 줄이는 동시에 일관된 경험을 줄 수 있다. material design이나 human interface guideline은 하나의 거대한 운영체제 하에서
      다양한 케이스를 망라하는 가이드이다. 이 모든 규칙을 엄격하게 수용하고 반영하려는 시도는 우리 제품의 당면한 문제인가?
    </p>

    <ul>
      <li>사용자 워크플로우를 중심으로 용법을 정의.</li>
      <li>
        거대 맥락을 제외하면 디자인 시스템에서 어떻게 정의하느냐에 따라 용법이 달라질 수 밖에 없다. 토스트 식빵처럼 튀어 나오는 것을 toast로 정의할
        것인지, 특정 위치(왼쪽 아래)에 위치하는 맥락으로 toast를 정의할 것인지. 너무 많은 콘텐츠를 모달에 표시하지 않도록 제한할 것인지, dribble,
        pinterest처럼 상세페이지 전체에 모달 뷰를 허용할 것인지?
      </li>
      <li>React portal의 개념을 가져와서 모든 Presentations를 루트 엘리먼트(body) 안에 위치시킬 수 있다. root -> page/modal/toast/sheet</li>
      <li>
        한 번에 하나의 presentation만 열 수 있다. 하지만 모달 안에서 드롭다운 등의 패턴은 허용할 것인가? 분명한 사실. 시트와 모달은 하나만 열 수 있다.
      </li>
    </ul> -->

    <h4 class="article-subhead">References</h4>
    <ul>
      <li>
        <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/presentation_role" target="_blank">ARIA: presentation role </a>
      </li>
      <li>
        <a href="https://developer.apple.com/design/human-interface-guidelines/components/presentation/action-sheets" target="_blank"
          >HIG action-sheets</a
        >
      </li>
    </ul>

    <h4 class="article-subhead">Related Components</h4>
    <ul>
      <li>Title bar</li>
      <li>Button group</li>
      <li>Dim/Overay</li>
      <li>Elevated tile</li>
      <li>CloseIcon / BackIcon</li>
    </ul>
    <h4 class="article-subhead">Triggers</h4>
    <ul>
      <li>window.load</li>
      <li>action button</li>
      <li>window.resize</li>
    </ul>

    <!-- <h4 class="article-subhead">인터렉션</h4>
    <ul>
      <li>Sheet (mobile)</li>
      <li>Modal (desktop)</li>
    </ul>
    <p style="margin:.5rem 0 1.5rem;">
      사용자 인터렉션을 요구할 때 overay으로 주의를 집중 시킵니다. toast는 단순 피드백으로, 뷰를 변경하지 않습니다.
    </p>
    <p>overay을 열고 body 엘리먼트의 스크롤을 막을 것인가. 스크롤의 크기만큼 좌우의 위치를 보정할 것인가. 비효율적인 작업량.</p> -->

    <div class="tile-flat">
      <b>memo</b>
      <p>md. When adapting for larger screens, a bottom sheet can become a context menu.</p>
      <p>md. Swap the bottom sheet for a side sheet in landscape layouts.</p>
      <p>md. sheet. modal bottom sheet. expanding bottom sheet.</p>
    </div>
  </section>

  <section class="component-body">
    <article class="article js-observer js-scrollspy-section">
      <h1 class="article-title">Page</h1>
      <p class="article-description">기본적인 콘텐츠 뷰</p>
      <ul>
        <li>검색 : 글로벌 / 로컬 패턴 정리 , Progressing. Loader의 레벨</li>
      </ul>
    </article>

    <article class="article js-observer js-scrollspy-section">
      <h1 class="article-title">Modal</h1>
      <p class="article-description">something that requires the user’s attention.</p>
      <footer>
        <button class="button-secondary js-modal" data-modal="woolf">모달 열기</button>
      </footer>
      <hr />
      <ul>
        <li>
          <b>사용자의 인터렉션.</b> 사용자가 모달을 해제할 때까지 이전 워크플로로 돌아갈 수 없습니다. 사용자의 워크플로를 완료하는 데 필요한 입력을
          요청. 편집 또는 관리와 같은 짧고 낮은 빈도.
        </li>
        <li>사용자가 모달을 직접 열 수 있는 트리거를 제공하세요. 현재 모달을 암시하는 기표는 없음. 사용자의 학습이 필요.</li>
        <li>이전 페이지와 맥락을 유지하는 콘텐츠 정보를 표시</li>
        <li>x button / arrow button, left / right</li>
        <!-- <li>All Modals have a max-width of 100%.</li> -->
        <li>
          중요도를 명확히 설정하는 것이 중요함. 정말로 중요한 입력이 요구되는 경우, 모달의 바깥을 클릭해서 닫을 수 없는 게 더 맞는 맥락. 또한 반드시
          모달이어야 하는가.
        </li>
        <!-- <li>
          팝업을 띄우면서 스크롤을 막으려면 스크롤바를 없애줘야 하는데, 이게 생각보다 복잡하다. 크롬에서는 html에 overflow:hidden를 잘 주면 끝인데,
          익스플로러에선 스크롤 제어하려면 body에 먹여야 한다. html에 overflow:hidden;을주고 모달에 overflow-y를 주면(조건:모달이 윈도우창보다
          작아질때)
        </li> -->
      </ul>
      <table>
        <thead>
          <tr>
            <td style="padding: var(--space-2) 0">
              <span class="icon-indicator is-positive" data-size="small">
                <span class="material-symbols-outlined">check</span>
              </span>
            </td>
            <td style="padding: var(--space-2) 0">
              <span class="icon-indicator is-negative" data-size="small"><span class="material-symbols-outlined">close</span></span>
            </td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <b>Close on outside click</b>
              <br />
              내용 없음
            </td>
            <td>
              <b>Non-modal dialog</b>
              <br />
              다이얼로그는 항상 모달로 사용합니다.
            </td>
          </tr>
        </tbody>
      </table>

      <h4 class="article-subhead">모달이 될 수 있는 컴포넌트</h4>
      <ul>
        <li>Page - portfolio work</li>
        <li>Dialog</li>
        <li>Multiple filters</li>
        <li>Dropdown menu</li>
      </ul>

      <h4 class="article-subhead">with Page <sup>800px</sup></h4>
      <aside class="modal tile-elevated" role="dialog" style="margin-left: -5vw; margin-right: -5vw; border-radius: 0; position: relative">
        <article class="modal-dialog" style="margin: 0">
          <!-- <header class="dialog-head"></header>
          <div class="dialog-body"></div> -->
          <header class="titlebar" style="padding: 0">
            <h1 class="titlebar-title">모달 제목</h1>
            <button class="titlebar-back" aria-label="이전 페이지로">
              <span class="material-symbols-outlined">arrow_back</span>
            </button>
          </header>
          <section style="padding: 2rem 0 0">
            <ul>
              <li>
                <b>with title bar component.</b> 모달 보기의 작업 이름을 지정하는 제목 또는 작업을 설명하거나 지침을 제공하는 추가 텍스트를 제공하면
                사람들이 앱에서 자신의 위치를​​유지하도록 도울 수 있습니다.
              </li>
              <li>sticky title bar.</li>
              <li>use case. user profile의 portfolio에서 사용.</li>
              <li>with button group.</li>
              <li>모바일에서 페이지처럼 보인다.</li>
            </ul>
          </section>
        </article>
      </aside>

      <h4 class="article-subhead">with Dialog <sup>400px</sup></h4>
      <aside class="dialog" role="alertdialog" aria-modal="true" aria-labelledby="dialog-title" aria-describedby="dialog-description">
        <h1 class="dialog-title" id="dialog-title">페이지를 나가시겠어요?</h1>
        <p class="dialog-description" id="dialog-description">아직 게시물을 공유하지 않았습니다. 게시하지 않고 나가시겠어요?</p>
        <footer class="dialog-footer">
          <button class="dialog-footer-confirm">나가기</button>
          <button class="dialog-footer-cancel">계속 작성</button>
        </footer>
        <button class="dialog-close js-close" aria-label="닫기"><span class="material-symbols-outlined">close</span></button>
      </aside>

      <h4 class="article-subhead">모달의 종료</h4>
      <ul>
        <li>click. Dim / CloseButton / ConfirmButton / CancelButton</li>
        <li>keydown. escKey. enterKey. spaceBar</li>
      </ul>

      <h4 class="article-subhead">모달의 기능</h4>
      <ul>
        <li>모달에 브라우저 히스토리를 저장해서 url을 통한 접근을 허용할 것인가.</li>
        <li>body element의 스크롤을 허용할 것인가.</li>
      </ul>

      <h4 class="article-subhead">Other cases</h4>
      <ul>
        <li>
          <b>ibm.</b> Don’t use to display complex or large amounts of data. Don’t recreate a full app or page in a dialog. 이 디자인 시스템에서는
          모달은 페이지가 될 수 있는 맥락이어야.
        </li>
        <li><b>ibm.</b> non-modal.</li>
        <li><b>airbnb.</b> 큰 화면에서 x 버튼. 모바일에서 페이지처럼 변하면서 arrow 버튼으로 변경됨</li>
        <li><b>pinterest.</b> onDismiss / Preventing close on outside click / layer component</li>
      </ul>

      <h4 class="article-subhead">References</h4>
      <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/alertdialog_role">alertdialog role</a>
    </article>

    <article class="article js-observer js-scrollspy-section">
      <h1 class="article-title">Toast</h1>
      <p class="article-description" title="temporary feedback on an interaction">일시적인 피드백. 현재 사용하지 않음.</p>

      <button class="button-secondary js-toggle">토스트 열기</button>
      <aside class="toast" role="alert">toast test. 사라지는 시간을 정의.</aside>

      <h4 class="article-subhead">Best practices</h4>
      <ul>
        <li>
          포지셔닝에 left bottom 좌표보다 margin을 쓰는 게 좋다. 미디어쿼리 재할당 속성이 적어지기 때문. left:1rem/right:1rem 이면 항상 block width를
          가짐.
        </li>
      </ul>

      <h4 class="article-subhead">토스트가 될 수 있는 컴포넌트</h4>
      <ul>
        <li>callout</li>
      </ul>

      <h4 class="article-subhead">toast VS snackbar</h4>
      <ul>
        <li>action 유/무. MD 버전업과 함께 용어와 기능이 변경된.</li>
      </ul>

      <h4 class="article-subhead">Cases</h4>
      <ul>
        <li>삭제 후 되돌리기. 휴지통이 있다면 대체할 수 있는 기능.</li>
        <li>HIG에 정의되지 않음. iOS spotify 앱에서 '라이브러리에 추가되었습니다'.</li>
      </ul>
    </article>

    <article class="article js-observer js-scrollspy-section">
      <h1 class="article-title">Sheet</h1>
      <p class="article-description">현재 사용하지 않음. 모바일을 위한.</p>
      <!-- <p>To allow users to view optional information or complete sub-tasks in a workflow while keeping the context of the current page, use Sheet.</p> -->
      <button class="button-secondary js-toggle">시트 열기</button>

      <article class="sheet js-sheet" role="presentation">
        <button class="sheet-toggle"></button>
        <h2 class="sheet-title">Presentation - sheet</h2>
        <button class="sheet-close js-sheet-close" aria-label="close sheet">
          <span class="material-symbols-outlined">close</span>
        </button>
        <button class="item" data-size="medium" role="menuitem">
          <figure class="item-avatar"></figure>
          <span class="item-label">iOS 액션 시트 참고</span>
        </button>
        <button class="item" data-size="medium" role="menuitem">
          <figure class="item-avatar"></figure>
          <span class="item-label">바텀 시트 옵션</span>
        </button>
      </article>
      <!-- <aside class="sheet-overay"></aside> -->

      <section class="component-example">
        <h2>iOS action sheet sample (modal view)</h2>
        <div class="tile-flat actionsheet">
          <button>action 1</button>
          <button style="margin: var(--space-05) 0">action 2</button>
          <button>action 3</button>
          <button style="margin: var(--space-2) 0 0 0; font-weight: var(--font-weight-bold)">닫기</button>
        </div>
      </section>

      <h4 class="article-subhead">시트가 될 수 있는 컴포넌트</h4>
      <ul>
        <li>dialog</li>
        <li>기능(역할) 단위 컴포넌트. 공유하기 등.</li>
      </ul>

      <ul>
        <li>데스크탑에서는 시트보다 모달의 사용성이 더 좋다. 모달이 충분히 대체할 수는 있다.</li>
        <li>토스트. Don't show more than one at a time.</li>
      </ul>
      <!-- <h4 class="article-subhead">Cases</h4>
      <ul>
        <li>액션시트. 네이버쇼핑과 왓챠에서 본 것 같음.</li>
      </ul> -->
    </article>

    <article class="article js-observer js-scrollspy-section">
      <h1 class="article-title">Popover</h1>
      <p class="article-description">floating tiles</p>
      <footer style="position: relative">
        <button class="button-secondary js-toggle">팝오버 열기</button>
        <div class="popover tile-elevated">
          <header class="titlebar" style="padding: 0">
            <h1 class="titlebar-title">프로필</h1>
            <button class="titlebar-back" aria-label="이전 페이지로">
              <span class="material-symbols-outlined">close</span>
            </button>
          </header>
          <section></section>
        </div>
      </footer>

      <h4 class="article-subhead">팝오버 컴포넌트</h4>
      <ul>
        <li>overflow menu</li>
        <li>tooltip</li>
      </ul>

      <ul>
        <li>큰화면에 어울리는 인터페이스. 작은 화면에서 모달이나 시트가 될 수 있어야 한다.</li>
        <li>한 번에 하나 이상을 열 수 없다.</li>
        <li>aria-haspopup</li>
        <li>aka. drawer</li>
      </ul>
    </article>
  </section>
</main>
